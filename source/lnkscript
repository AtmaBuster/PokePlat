/* Linker Script Original v1.3 by Jeff Frohwein     */
/*  v1.0 - Original release                         */
/*  v1.1 - Added proper .data section support       */
/*  v1.2 - Added support for c++ & iwram overlays   */
/*       - Major contributions by Jason Wilkins.    */
/*  v1.3 - .ewram section now can be used when      */
/*         compiling for MULTIBOOT mode. This fixes */
/*         malloc() in DevKitAdvance which depends  */
/*         on __eheap_start instead of end to define*/
/*         the starting location of heap space.     */
/*         External global variable __gba_iwram_heap*/
/*         support added to allow labels end, _end, */
/*         & __end__ to point to end of iwram or    */
/*         the end of ewram.                        */
/*	Additions by WinterMute				*/
/* v1.4 -	.sbss section added for unitialised	*/
/*		    data in ewram 			*/
/* v1.5 -	padding section added to stop EZF 	*/
/*		    stripping important data		*/

/* This file is released into the public domain		*/
/* for commercial or non-commercial use with no		*/
/* restrictions placed upon it.				*/

/* NOTE!!!: This linker script defines the RAM &  */
/*   ROM start addresses. In order for it to work */
/*   properly, remove -Ttext and -Tbss linker     */
/*   options from your makefile if they are       */
/*   present.                                     */

/* You can use the following to view section      */
/* addresses in your .elf file:                   */
/*   objdump -h file.elf                          */
/* Please note that empty sections may incorrectly*/
/* list the lma address as the vma address for    */
/* some versions of objdump.                      */

OUTPUT_FORMAT("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
OUTPUT_ARCH(arm)
ENTRY(_start)
/* SEARCH_DIR(/bin/arm); */

/* The linker script function "var1 += var2;" sometimes    */
/* reports incorrect values in the *.map file but the      */
/* actual value it calculates is usually, if not always,   */
/* correct. If you leave out the ". = ALIGN(4);" at the    */
/* end of each section then the return value of SIZEOF()   */
/* is sometimes incorrect and "var1 += var2;" appears to   */
/* not work as well. "var1 += var2" style functions are    */
/* avoided below as a result.                              */

MEMORY {

	rom	: ORIGIN = 0x02000000, LENGTH = 32M
	iwram	: ORIGIN = 0x021d0d80, LENGTH = 8M
	iwram_221fc20 : ORIGIN = 0x0221fc20, LENGTH = 8M
	iwram_223e140 : ORIGIN = 0x0223e140, LENGTH = 8M
	iwram_2249960 : ORIGIN = 0x02249960, LENGTH = 8M
	iwram_2253ce0 : ORIGIN = 0x02253ce0, LENGTH = 8M
	ewram	: ORIGIN = 0x02000000, LENGTH = 8M
	ewram2	: ORIGIN = 0x01ff8000, LENGTH = 8M
}

__text_start	=	ORIGIN(rom);
__eheap_end	=	ORIGIN(ewram) + LENGTH(ewram);
__iwram_start	=	ORIGIN(iwram);
__iwram_top	=	ORIGIN(iwram) + LENGTH(iwram);;
__iwram_221fc20_start	=	ORIGIN(iwram_221fc20);
__iwram_221fc20_top	=	ORIGIN(iwram_221fc20) + LENGTH(iwram_221fc20);;
__iwram_223e140_start	=	ORIGIN(iwram_223e140);
__iwram_223e140_top	=	ORIGIN(iwram_223e140) + LENGTH(iwram_223e140);;
__iwram_2249960_start	=	ORIGIN(iwram_2249960);
__iwram_2249960_top	=	ORIGIN(iwram_2249960) + LENGTH(iwram_2249960);;
__sp_irq	=	__iwram_top - 0x060;
__sp_usr	=	__sp_irq - 0x0a0;
__irq_flags	=	0x03007ff8;
__irg_handler = 0x01ff8000;

SECTIONS
{
	. = __text_start;
	.init :
	{
		KEEP (*(.init))
		. = ALIGN(4);
	} >rom =0xff

	.plt :
	{
		*(.plt)
		. = ALIGN(4);   /* REQUIRED. LD is flaky without it. */
	} >rom

	.text  :   /* ALIGN (4): */
	{
/*		*(EXCLUDE_FILE (*.iwram*) .text)
		*(.text .stub .text.* .gnu.linkonce.t.*)
		KEEP (*(.text.*personality*))*/
		/* .gnu.warning sections are handled specially by elf32.em.  */
/*		*(.gnu.warning)
		*(.glue_7t) *(.glue_7) *(.vfp11_veneer)*/
		. = ALIGN(4);  /* REQUIRED. LD is flaky without it. */
	} >rom = 0xff

	__text_end = .;    
	.fini           :
	{
		KEEP (*(.fini))
		. = ALIGN(4);  /* REQUIRED. LD is flaky without it. */
	} >rom =0

	.rodata :
	{
		*(.rodata)
		*all.rodata*(*)
		*(.roda)
		*(.rodata.*)
		*(.gnu.linkonce.r*)
		SORT(CONSTRUCTORS)
		. = ALIGN(4);   /* REQUIRED. LD is flaky without it. */
	} >rom = 0xff
	.ARM.extab   : { *(.ARM.extab* .gnu.linkonce.armextab.*) } >rom
	__exidx_start = .;
	.ARM.exidx   : { *(.ARM.exidx* .gnu.linkonce.armexidx.*) } >rom
	__exidx_end = .;
    
    
    	__ewram_start = ORIGIN(ewram);
        __ewram_lma = __ewram_start;
	.ewram __ewram_start : AT (__ewram_lma)
	{
		*(.ewram)
		/*. = ALIGN(4);   REQUIRED. LD is flaky without it. */
		__ewram_end = ABSOLUTE(.);
	}>ewram = 0xff

	__ewram2_start = 0x2101d20; /*__ewram_lma + SIZEOF(.ewram);*/
	.ewram2 __irg_handler : AT (__ewram2_start)
	{
		*(.ewram2)
		/*. = ALIGN(4);   REQUIRED. LD is flaky without it. */
		__ewram2_end = ABSOLUTE(.);
	}>ewram2 = 0xff

	__ewram3_start = __ewram2_start + SIZEOF(.ewram2);
	.ewram3 __ewram3_start : AT (__ewram3_start)
	{
		*(.ewram3)
		__ewram3_end = ABSOLUTE(.);
	}>ewram = 0xff
    
/*	__ewram3f_start = __ewram3_start + SIZEOF(.ewram3);
	.fill0 __ewram3f_start : AT (__ewram3f_start)
	{
		FILL(0xFF);
		. = . + ((((__ewram3f_start) + 0x200 - 1) & ~(0x200 - 1)) - (__ewram3f_start)) - 1;
	    BYTE(0xFF);
	} > ewram = 0xff*/
    
	/*__pad_lma = __ewram_lma + SIZEOF(.ewram);*/
	__pad_lma = __ewram3_start + SIZEOF(.ewram3);

	.sbss ALIGN(4)(NOLOAD):
 	{
		__sbss_start__ = ABSOLUTE(.);
 		*(.sbss)
 		. = ALIGN(4);
		__sbss_end__  = ABSOLUTE(.);
		__end__ = ABSOLUTE(.);
		__eheap_start = ABSOLUTE(.);
 	} AT>ewram
    

	__iwram_lma = .;

	.bss ALIGN(4) (NOLOAD) :
	{
		__bss_start = ABSOLUTE(.);
		__bss_start__ = ABSOLUTE(.);
		*(.dynbss)
		*(.gnu.linkonce.b*)
		*(.bss*)
		*(COMMON)
		. = ALIGN(4);    /* REQUIRED. LD is flaky without it. */
		__bss_end__ = ABSOLUTE(.);

	}

	.bss2 (0x27e0000) (NOLOAD) :
	{
		__bss2_start = ABSOLUTE(.);
		__bss2_start__ = ABSOLUTE(.);
/*		*(.dynbss)
		*(.gnu.linkonce.b*)*/
		*(.bss2*)
/*		*(COMMON)*/
		. = ALIGN(4);    /* REQUIRED. LD is flaky without it. */
		__bss2_end__ = ABSOLUTE(.);

	}

	.iwram __iwram_start : AT (__iwram_lma)
	{
		__iwram_start__ = ABSOLUTE(.) ;
		*(.iwram)
		*iwram.*(.text)
		. = ALIGN(4);   /* REQUIRED. LD is flaky without it. */
		__iwram_end__ = ABSOLUTE(.) ;
	} >iwram = 0xff

	__data_lma = __iwram_lma + SIZEOF(.iwram);



	.data ALIGN(4) : AT (__data_lma)
	{
		__data_start__ = ABSOLUTE(.);
		*(.data)
		*(.data.*)
		*(.gnu.linkonce.d*)
		CONSTRUCTORS
		. = ALIGN(4);
	} >iwram = 0xff

	__preinit_lma = __data_lma + SIZEOF(.data);

	.preinit_array ALIGN(4)    : AT (__preinit_lma)
	{
		__preinit_array_start = ABSOLUTE(.);
		KEEP (*(.preinit_array))
		__preinit_array_end = ABSOLUTE(.);
	} >iwram

	__init_lma = __preinit_lma + SIZEOF(.preinit_array);

	.init_array  ALIGN(4)   : AT (__init_lma)
	{
		__init_array_start = ABSOLUTE(.);
		KEEP (*(SORT(.init_array.*)))
		KEEP (*(.init_array))
		__init_array_end = ABSOLUTE(.);
	} >iwram

	__fini_lma = __init_lma + SIZEOF(.init_array);

	.fini_array  ALIGN(4)   : AT (__fini_lma)
	{
		__fini_array_start = ABSOLUTE(.);
		KEEP (*(SORT(.fini_array.*)))
		KEEP (*(.fini_array))
  		__fini_array_end = ABSOLUTE(.);
	} >iwram

	__jcr_lma = __fini_lma + SIZEOF(.fini_array);
	.jcr        ALIGN(4)    : AT (__jcr_lma) { KEEP (*(.jcr)) } >iwram

	__data_end__  =  ABSOLUTE(.);

    
	__iwram_223e140_lma = .;

	.iwram_223e140 __iwram_223e140_start : AT (__iwram_223e140_lma)
	{
		__iwram_223e140_start__ = ABSOLUTE(.) ;
		*(.iwram_223e140)
		*iwram_223e140.*(.text)
		. = ALIGN(4);   /* REQUIRED. LD is flaky without it. */
		__iwram_223e140_end__ = ABSOLUTE(.) ;
	} >iwram_223e140 = 0xff

	__data_lma_iwram_223e140 = __iwram_223e140_lma + SIZEOF(.iwram_223e140);
    

	.iwram4 __iwram_start : AT (__iwram_overlay_lma) { *(.iwram4) . = ALIGN(4); } > iwram = 0xff
	__load_start_iwram2 = LOADADDR (.iwram4);
	__load_stop_iwram2 = LOADADDR (.iwram4) + SIZEOF (.iwram4);
	.fill4 :
	{
		FILL(0xFF);
		/*. = . + ((__load_start_iwram2 + (__load_stop_iwram2 - __load_start_iwram2)) + 0x200 - 1) & ~(0x200 - 1) - (__load_start_iwram2 + (__load_stop_iwram2 - __load_start_iwram2));*/
		. = . + ((((__load_stop_iwram2) + 0x200 - 1) & ~(0x200 - 1)) - (__load_stop_iwram2)) - 1;
		/*. = . + 0x180;*/
	    BYTE(0xFF);
	} > iwram = 0xff
    
	.iwram5 __iwram_start : AT (__iwram_overlay_lma + SIZEOF (.iwram4) + SIZEOF (.fill4)) { *(.iwram5) . = ALIGN(4); } > iwram = 0xff
	__load_start_iwram3 = LOADADDR (.iwram5);
	__load_stop_iwram3 = LOADADDR (.iwram5) + SIZEOF (.iwram5);
	.fill5 :
	{
		FILL(0xFF);
		. = . + ((((__load_stop_iwram3) + 0x200 - 1) & ~(0x200 - 1)) - (__load_stop_iwram3)) - 1;
	    BYTE(0xFF);
	} > iwram = 0xff
    
	__iwram_overlay_lma = __jcr_lma + SIZEOF(.jcr);

	__iwram_overlay_start = . ;
    
	.iwram6 __iwram_223e140_start : AT (__iwram_overlay_lma + SIZEOF (.iwram4) + SIZEOF (.fill4) + SIZEOF (.iwram5) + SIZEOF (.fill5)) { *(.iwram6) . = ALIGN(4); } > iwram_223e140 = 0xff
	__load_start_iwram6 = LOADADDR (.iwram6);
	__load_stop_iwram6 = LOADADDR (.iwram6) + SIZEOF (.iwram6);
/*	.fill6 :
	{
		FILL(0xFF);
        offset = MAX(0x200, -1);
		. = . + 0;
	    BYTE(0xFF);
	} > iwram_223e140 = 0xff*/
    
    temp7 = __iwram_overlay_lma + SIZEOF (.iwram4) + SIZEOF (.fill4) + SIZEOF (.iwram5) + SIZEOF (.fill5) + SIZEOF (.iwram6);
	.iwram7 __iwram_2249960_start : AT (temp7) { *(.iwram7) . = ALIGN(4); } > iwram_2249960 = 0xff
	__load_start_iwram7 = LOADADDR (.iwram7);
	__load_stop_iwram7 = LOADADDR (.iwram7) + SIZEOF (.iwram7);
	.fill7 :
	{
		FILL(0xFF);
		. = . + ((((__load_stop_iwram7) + 0x200 - 1) & ~(0x200 - 1)) - (__load_stop_iwram7)) - 1;
	    BYTE(0xFF);
	} > iwram_2249960 = 0xff
    
    temp8 = temp7 + SIZEOF (.iwram7) + SIZEOF (.fill7);
	.iwram8 __iwram_2249960_start : AT (temp8) { *(.iwram8) . = ALIGN(4); } > iwram_2249960 = 0xff
	__load_start_iwram8 = LOADADDR (.iwram8);
	__load_stop_iwram8 = LOADADDR (.iwram8) + SIZEOF (.iwram8);
	.fill8 :
	{
		FILL(0xFF);
		. = . + ((((__load_stop_iwram8) + 0x200 - 1) & ~(0x200 - 1)) - (__load_stop_iwram8)) - 1;
	    BYTE(0xFF);
	} > iwram_2249960 = 0xff
    
    temp9 = temp8 + SIZEOF (.iwram8) + SIZEOF (.fill8);
	.iwram9 __iwram_2249960_start : AT (temp9) { *(.iwram9) . = ALIGN(4); } > iwram_2249960 = 0xff
	__load_start_iwram9 = LOADADDR (.iwram9);
	__load_stop_iwram9 = LOADADDR (.iwram9) + SIZEOF (.iwram9);
	.fill9 :
	{
		FILL(0xFF);
		. = . + ((((__load_stop_iwram9) + 0x200 - 1) & ~(0x200 - 1)) - (__load_stop_iwram9)) - 1;
	    BYTE(0xFF);
	} > iwram_2249960 = 0xff
    
    temp10 = temp9 + SIZEOF (.iwram9) + SIZEOF (.fill9);
	.iwram10 __iwram_2249960_start : AT (temp10) { *(.iwram10) . = ALIGN(4); } > iwram_2249960 = 0xff
	__load_start_iwram10 = LOADADDR (.iwram10);
	__load_stop_iwram10 = LOADADDR (.iwram10) + SIZEOF (.iwram10);
	.fill10 :
	{
		FILL(0xFF);
		. = . + ((((__load_stop_iwram10) + 0x200 - 1) & ~(0x200 - 1)) - (__load_stop_iwram10)) - 1;
	    BYTE(0xFF);
	} > iwram_2249960 = 0xff
    
    temp11 = temp10 + SIZEOF (.iwram10) + SIZEOF (.fill10);
	.iwram11 __iwram_2249960_start : AT (temp11) { *(.iwram11) . = ALIGN(4); } > iwram_2249960 = 0xff
	__load_start_iwram11 = LOADADDR (.iwram11);
	__load_stop_iwram11 = LOADADDR (.iwram11) + SIZEOF (.iwram11);
	.fill11 :
	{
		FILL(0xFF);
		. = . + ((((__load_stop_iwram11) + 0x200 - 1) & ~(0x200 - 1)) - (__load_stop_iwram11)) - 1;
	    BYTE(0xFF);
	} > iwram_2249960 = 0xff
    
    temp12 = temp11 + SIZEOF (.iwram11) + SIZEOF (.fill11);
	.iwram12 __iwram_221fc20_start : AT (temp12) { *(.iwram12) . = ALIGN(4); } > iwram_221fc20 = 0xff
	__load_start_iwram12 = LOADADDR (.iwram12);
	__load_stop_iwram12 = LOADADDR (.iwram12) + SIZEOF (.iwram12);
	.fill12 :
	{
		FILL(0xFF);
		. = . + ((((__load_stop_iwram12) + 0x200 - 1) & ~(0x200 - 1)) - (__load_stop_iwram12)) - 1;
	    BYTE(0xFF);
	} > iwram_221fc20 = 0xff
    
    
	. = __iwram_overlay_lma + MAX (SIZEOF (.iwram4), SIZEOF (.iwram5));

/*	OVERLAY ALIGN(4) : NOCROSSREFS AT (__iwram_overlay_lma)
	{
		.iwram0 { *(.iwram0) . = ALIGN(4);}
		.iwram1 { *(.iwram1) . = ALIGN(4);}*/
		/*.iwram4 { *(.iwram4) . = ALIGN(4);}*/
        /*test = ABSOLUTE(.);*/
/*		.fill2
		{
		FILL(0xFF);
		. = ((LOADADDR (.iwram4) + SIZEOF (.iwram4)) + 0x200 - 1) & ~(0x200 - 1) - (LOADADDR (.iwram4) + SIZEOF (.iwram4));
		}*/
		/*.iwram5 { *(.iwram5) . = ALIGN(0x200);}
		.iwram4 { *(.iwram4) . = ALIGN(4);}
		.iwram5 { *(.iwram5) . = ALIGN(4);}
		.iwram6 { *(.iwram6) . = ALIGN(4);}
		.iwram7 { *(.iwram7) . = ALIGN(4);}
		.iwram8 { *(.iwram8) . = ALIGN(4);}
		.iwram9 { *(.iwram9) . = ALIGN(4);}
	}>iwram = 0xff*/
  
/*	__iwram_overlay_end1 = ABSOLUTE(.);
	.fill3 :
	{
	FILL(0xFF);
	. = . + ((__iwram_overlay_lma + (__iwram_overlay_end1 - __iwram_overlay_start)) + 0x200 - 1) & ~(0x200 - 1) - (__iwram_overlay_lma + (__iwram_overlay_end1 - __iwram_overlay_start));
    BYTE(0xAA);
	} > iwram = 0xff*/

	__iwram_overlay_end = . ;

	/*__iwram_overlay_end = . ;*/
	/*__iwram_overlay_end = . + (((LOADADDR (.iwram5) + SIZEOF (.iwram5)) + 0x200 - 1) & ~(0x200 - 1)) - (LOADADDR (.iwram5) + SIZEOF (.iwram5));*/
	__ewram_lma = __iwram_overlay_lma + (__iwram_overlay_end - __iwram_overlay_start) ;

	__iheap_start = . ;



	/* EZF Advance strips trailing 0xff bytes, add a pad section so nothing important is removed */
/*	.pad ALIGN(4) : AT (__pad_lma)
	{
		LONG(0x52416b64)
		LONG(0x4d)
		. = ALIGN(4);
	} = 0xff
	__rom_end__ = __pad_lma + SIZEOF(.pad);*/
	__rom_end__ = __pad_lma;


	/* Stabs debugging sections.  */
/*	.stab 0 : { *(.stab) }
	.stabstr 0 : { *(.stabstr) }
	.stab.excl 0 : { *(.stab.excl) }
	.stab.exclstr 0 : { *(.stab.exclstr) }
	.stab.index 0 : { *(.stab.index) }
	.stab.indexstr 0 : { *(.stab.indexstr) }
	.comment 0 : { *(.comment) }*/
	/*	DWARF debug sections.
		Symbols in the DWARF debugging sections are relative to the beginning
		of the section so we begin them at 0.  */
	/* DWARF 1 */
/*	.debug          0 : { *(.debug) }
	.line           0 : { *(.line) }*/
	/* GNU DWARF 1 extensions */
/*	.debug_srcinfo  0 : { *(.debug_srcinfo) }
	.debug_sfnames  0 : { *(.debug_sfnames) }*/
	/* DWARF 1.1 and DWARF 2 */
/*	.debug_aranges  0 : { *(.debug_aranges) }
	.debug_pubnames 0 : { *(.debug_pubnames) }*/
	/* DWARF 2 */
/*	.debug_info     0 : { *(.debug_info) }
	.debug_abbrev   0 : { *(.debug_abbrev) }
	.debug_line     0 : { *(.debug_line) }
	.debug_frame    0 : { *(.debug_frame) }
	.debug_str      0 : { *(.debug_str) }
	.debug_loc      0 : { *(.debug_loc) }
	.debug_macinfo  0 : { *(.debug_macinfo) }*/
	/* SGI/MIPS DWARF 2 extensions */
/*	.debug_weaknames 0 : { *(.debug_weaknames) }
	.debug_funcnames 0 : { *(.debug_funcnames) }
	.debug_typenames 0 : { *(.debug_typenames) }
	.debug_varnames  0 : { *(.debug_varnames) }
	.stack 0x80000 : { _stack = .; *(.stack) }*/
	/* These must appear regardless of  .  */
/*  .note.gnu.arm.ident 0 : { KEEP (*(.note.gnu.arm.ident)) }
  .ARM.attributes 0 : { KEEP (*(.ARM.attributes)) }
  /DISCARD/ : { *(.note.GNU-stack) }*/
}
